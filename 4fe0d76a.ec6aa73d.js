(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{77:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return u}));var r=n(3),a=n(7),i=(n(0),n(92)),o={id:"battery-life",title:"Battery Life",sidebar_label:"Battery Life",slug:"/battery-life"},c={unversionedId:"battery-life",id:"battery-life",isDocsHomePage:!1,title:"Battery Life",description:"Watchy wakes up every 60 seconds to check the accelerometer, real-time clock, and updates the E-Paper display with the latest information. Certain watch faces also turn on WiFi to fetch weather data.",source:"@site/docs/battery-life.md",slug:"/battery-life",permalink:"/docs/battery-life",editUrl:"https://github.com/sqfmi/watchy-site/docs/battery-life.md",version:"current",sidebar_label:"Battery Life",sidebar:"docs",previous:{title:"Create Your Own Watch Face",permalink:"/docs/create-watchface"},next:{title:"Hardware",permalink:"/docs/hardware"}},l=[{value:"Tips",id:"tips",children:[]}],s={toc:l};function u(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Watchy wakes up every 60 seconds to check the accelerometer, real-time clock, and updates the E-Paper display with the latest information. Certain watch faces also turn on WiFi to fetch weather data."),Object(i.b)("p",null,"With only time keeping, Watchy should have a battery life of 5-7 days, while with fetching data over WiFi, it should last between 2-3 days. These numbers can be extended through futher optimizations (e.g. sleep during off hours, waking up only on motion/tilt, etc.)."),Object(i.b)("h2",{id:"tips"},"Tips"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Put Watchy to deep sleep if it's not doing anything, the ESP32 is powerful and power hungry, leaving it idling will drain the battery and create unwanted heat. This is already done for you in the ",Object(i.b)("inlineCode",{parentName:"li"},"init()")," method, so there is no need to explicitly call it again unless you are doing something outside of the Watchy class.")),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"    void Watchy::deepSleep(){\n        esp_sleep_enable_ext0_wakeup(RTC_PIN, 0); //enable deep sleep wake on RTC interrupt\n        esp_sleep_enable_ext1_wakeup(BTN_PIN_MASK, ESP_EXT1_WAKEUP_ANY_HIGH); //enable deep sleep wake on button press\n        esp_deep_sleep_start();\n    }\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Turn off the radio after using WiFi/Bluetooth for communications. This will maximize Watchy's battery life.")),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"    //turn off radios\n    WiFi.mode(WIFI_OFF);\n    btStop();\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Put the display to sleep after updating: ",Object(i.b)("inlineCode",{parentName:"li"},"display.hibernate()"),". This is already done for you, so there is no need to explicitly call it again unless you are doing something outside of the Watchy class."),Object(i.b)("li",{parentName:"ul"},"If your watch face does not require a step counter, you can skip initializing and reading from the BMA423 accelerometer."),Object(i.b)("li",{parentName:"ul"},"If your watch face does not require 60 second updates (e.g. word clock), you can change the RTC alarm trigger to a longer period")))}u.isMDXComponent=!0},92:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return b}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),u=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=u(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},f=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),p=u(n),f=r,b=p["".concat(o,".").concat(f)]||p[f]||d[f]||i;return n?a.a.createElement(b,c(c({ref:t},s),{},{components:n})):a.a.createElement(b,c({ref:t},s))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=f;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var s=2;s<i;s++)o[s]=n[s];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}f.displayName="MDXCreateElement"}}]);