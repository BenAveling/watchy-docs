(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{89:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return o})),r.d(t,"metadata",(function(){return c})),r.d(t,"toc",(function(){return s})),r.d(t,"default",(function(){return p}));var a=r(3),i=r(7),n=(r(0),r(99)),o={id:"libs",title:"Libraries Used",sidebar_label:"Libraries Used",slug:"/libs"},c={unversionedId:"libs",id:"libs",isDocsHomePage:!1,title:"Libraries Used",description:"The Watchy library depends on other open source libraries to drive all of its hardware, some of which have been wrapped in `Watchy.h` to provide a framework for building watch faces and apps.",source:"@site/docs/libraries.md",slug:"/libs",permalink:"/docs/libs",editUrl:"https://github.com/sqfmi/watchy-site/docs/libraries.md",version:"current",sidebar_label:"Libraries Used",sidebar:"docs",previous:{title:"Getting Started",permalink:"/docs/getting-started"},next:{title:"Examples",permalink:"/docs/examples"}},s=[{value:"Display Graphics",id:"display-graphics",children:[{value:"GxEPD2",id:"gxepd2",children:[]},{value:"Adafruit GFX",id:"adafruit-gfx",children:[]}]},{value:"Time Keeping",id:"time-keeping",children:[{value:"DS3232RTC",id:"ds3232rtc",children:[]}]},{value:"Motion Sensing",id:"motion-sensing",children:[{value:"BMA423",id:"bma423",children:[]}]},{value:"Connectivity &amp; Data",id:"connectivity--data",children:[{value:"WiFiManager",id:"wifimanager",children:[]},{value:"Arduino_JSON",id:"arduino_json",children:[]}]}],l={toc:s};function p(e){var t=e.components,r=Object(i.a)(e,["components"]);return Object(n.b)("wrapper",Object(a.a)({},l,r,{components:t,mdxType:"MDXLayout"}),Object(n.b)("p",null,"The Watchy library depends on other open source libraries to drive all of its hardware, some of which have been wrapped in ",Object(n.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/sqfmi/Watchy/blob/master/src/Watchy.h"}),Object(n.b)("inlineCode",{parentName:"a"},"Watchy.h"))," to provide a framework for building watch faces and apps."),Object(n.b)("h2",{id:"display-graphics"},"Display Graphics"),Object(n.b)("h3",{id:"gxepd2"},"GxEPD2"),Object(n.b)("p",null,Object(n.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/ZinggJM/GxEPD2"}),"GxEPD2")," is an Arduino Display Library for SPI E-Paper Displays. It abstracts the SPI communication required to drive Watchy's E-Paper display, the GDEH0154D67. This library depends on the Adafruit GFX library, which provides the graphic primitives methods for drawing images, shapes, text, etc."),Object(n.b)("h3",{id:"adafruit-gfx"},"Adafruit GFX"),Object(n.b)("p",null,Object(n.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/adafruit/Adafruit-GFX-Library"}),"Adafruit GFX")," provides methods such as ",Object(n.b)("inlineCode",{parentName:"p"},"display.drawRect()")," for drawing shapes, ",Object(n.b)("inlineCode",{parentName:"p"},"display.drawBitmap()")," for drawing images, and ",Object(n.b)("inlineCode",{parentName:"p"},'display.println("Hello World!")')," for printing text."),Object(n.b)("p",null,"Visit ",Object(n.b)("ins",null,Object(n.b)("a",Object(a.a)({parentName:"p"},{href:"https://learn.adafruit.com/adafruit-gfx-graphics-library/overview"}),"https://learn.adafruit.com/adafruit-gfx-graphics-library/overview"))," for more details."),Object(n.b)("p",null,"See ",Object(n.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/create-watchface"}),Object(n.b)("strong",{parentName:"a"},"Create Your Own Watch Face"))," to learn how to use custom fonts and converting graphics to byte arrays."),Object(n.b)("h2",{id:"time-keeping"},"Time Keeping"),Object(n.b)("h3",{id:"ds3232rtc"},"DS3232RTC"),Object(n.b)("p",null,Object(n.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/JChristensen/DS3232RTC"}),"DS3232RTC")," is an Arduino library for the DS3231 Real-Time Clock. You can set and read the current time/date and configure alarm interrupts. The DS3231 RTC on Watchy is connected over I2C, so it requires the Wire Arduino library. The Watchy library configues ",Object(n.b)("em",{parentName:"p"},"Alarm2")," to trigger an interrupt every minute, waking the ESP32 from deep sleep to update the watch face."),Object(n.b)("h2",{id:"motion-sensing"},"Motion Sensing"),Object(n.b)("h3",{id:"bma423"},"BMA423"),Object(n.b)("p",null,Object(n.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/BoschSensortec/BMA423-Sensor-API"}),"BMA423 Sensor API")," is a C library for the BMA423, an ultra-small, triaxial, low-g acceleration sensor. The Watchy library provides a simple C++ Arduino API on top to simplify sensor readings such as direction sensing and step counting. The current Watchy library will be updated shortly to utilize the latest implementation from Bosch."),Object(n.b)("h2",{id:"connectivity--data"},"Connectivity & Data"),Object(n.b)("h3",{id:"wifimanager"},"WiFiManager"),Object(n.b)("p",null,Object(n.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/tzapu/WiFiManager"}),"WiFiManager")," sets up an access point captive portal, allowing you to connect and enter your WiFi credentials. These credentials are then saved in ESP32's flash, thus only requiring you to enter them once. Alternatively, you can also hard code your credentials in the ",Object(n.b)("inlineCode",{parentName:"p"},"config.h"),"."),Object(n.b)("h3",{id:"arduino_json"},"Arduino_JSON"),Object(n.b)("p",null,Object(n.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/arduino-libraries/Arduino_JSON"}),"Arduino_JSON")," is used for parsing JSON string responses from API calls. Check out Watchy's ",Object(n.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/sqfmi/Watchy/blob/master/src/Watchy.cpp#L457"}),Object(n.b)("inlineCode",{parentName:"a"},"getWeather()"))," method example on how its used for parsing data from OpenWeather's REST API."))}p.isMDXComponent=!0},99:function(e,t,r){"use strict";r.d(t,"a",(function(){return d})),r.d(t,"b",(function(){return h}));var a=r(0),i=r.n(a);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function c(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,i=function(e,t){if(null==e)return{};var r,a,i={},n=Object.keys(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=i.a.createContext({}),p=function(e){var t=i.a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):c(c({},t),e)),r},d=function(e){var t=p(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},u=i.a.forwardRef((function(e,t){var r=e.components,a=e.mdxType,n=e.originalType,o=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),d=p(r),u=a,h=d["".concat(o,".").concat(u)]||d[u]||b[u]||n;return r?i.a.createElement(h,c(c({ref:t},l),{},{components:r})):i.a.createElement(h,c({ref:t},l))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var n=r.length,o=new Array(n);o[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var l=2;l<n;l++)o[l]=r[l];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,r)}u.displayName="MDXCreateElement"}}]);